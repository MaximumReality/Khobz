<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Maximum Reality: The Bureaucracy Heist</title>
    <style>
        body { margin: 0; padding: 0; background-color: #0a0a0a; overflow: hidden; height: 100dvh; font-family: 'Courier New', monospace; }
        canvas {
            width: 100vw;
            height: 100dvh;
            display: block;
            touch-action: none;
        }
        #ui { position: absolute; top: 10px; left: 10px; color: #00f3ff; pointer-events: none; text-shadow: 0 0 5px #00f3ff; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui">SCORE: <span id="score">0</span></div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');

        // 1. Assets & State
        const bg = new Image();
        bg.src = 'cyberpunk_city_bg.JPG'; 

        const sprites = {};
        const frameNames = ['arms_up', 'stand_west', 'idle', 'stand_east', 'reach', 'stand'];
        frameNames.forEach(name => {
            sprites[name] = new Image();
            sprites[name].src = `lori_${name}.png`;
        });

        let gameState = {
            player: { x: window.innerWidth / 2, y: window.innerHeight - 150 }, 
            score: 0,
            movingLeft: false,
            movingRight: false,
            currentSprite: 'stand'
        };

        let obstacles = [];

        // 2. Responsive Setup
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Anchors Lori 150px from the bottom of the CURRENT visible area
            gameState.player.y = canvas.height - 150; 
        }
        window.addEventListener('resize', resize);
        resize();

        // 3. Spawning & Movement Logic
        function spawnObstacle() {
            const types = [
                { label: "ðŸ¥–", type: "khobz", value: 10 },
                { label: "ðŸ’”", type: "spam", value: -20 },
                { label: "ðŸ“§", type: "ssa_form", value: 50 },
                { label: "â­", type: "michelin_star", value: 100 },
                { label: "ðŸ‘»", type: "macy_ghost", value: 0 },
                { label: "ðŸ’Š", type: "spam_capsule", value: -50 }
            ];
            const choice = types[Math.floor(Math.random() * types.length)];
            obstacles.push({
                x: Math.random() * (canvas.width - 40),
                y: -50,
                speed: 3 + Math.random() * 4,
                ...choice
            });
        }

        canvas.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            const newX = touch.clientX;
            
            gameState.movingLeft = newX < gameState.player.x - 5;
            gameState.movingRight = newX > gameState.player.x + 5;
            gameState.player.x = newX;
            
            e.preventDefault();
        }, { passive: false });

        // 4. Update Engine
        function update() {
            let isReaching = false;

            obstacles.forEach((ob, index) => {
                ob.y += ob.speed;

                let dx = gameState.player.x - ob.x;
                let dy = gameState.player.y - ob.y;
                let dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 60) {
                    gameState.score += ob.value;
                    scoreElement.innerText = gameState.score;
                    obstacles.splice(index, 1);
                }

                // If a "good" item is close, trigger the reach sprite
                if (dist < 120 && ob.value > 0) isReaching = true;
            });

            if (isReaching) gameState.currentSprite = 'reach';
            else if (gameState.movingLeft) gameState.currentSprite = 'stand_west';
            else if (gameState.movingRight) gameState.currentSprite = 'stand_east';
            else gameState.currentSprite = 'stand';

            obstacles = obstacles.filter(ob => ob.y < canvas.height);
        }

        // 5. Draw Loop
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Layer 1: Desaturated Background
            if (bg.complete) {
                ctx.filter = 'grayscale(100%) brightness(35%) contrast(110%)';
                ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
                ctx.filter = 'none'; // Reset for characters
            }

            // Layer 2: Cyber-Lori
            const img = sprites[gameState.currentSprite];
            if (img && img.complete) {
                // Adjusting draw to keep her centered on the touch point
                ctx.drawImage(img, gameState.player.x - 50, gameState.player.y - 75, 100, 150);
            }

            // Layer 3: Colored Items
            ctx.font = "40px serif";
            obstacles.forEach(ob => {
                ctx.fillText(ob.label, ob.x, ob.y);
            });

            update();
            requestAnimationFrame(draw);
        }

        setInterval(spawnObstacle, 1000);
        draw();
    </script>
</body>
</html>
